import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as ssm from 'aws-cdk-lib/aws-ssm';
import * as fs from 'fs';
import * as path from 'path';

export class Ec2Stack extends Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // 1) KnowledgeBaseId 파라미터
    const knowledgeBaseId = new cdk.CfnParameter(this, 'knowledgeBaseId', {
      type: 'String',
      description: 'Knowledge Base ID for RAG Chatbot',
    });

    // 2) KnowledgeBaseId를 SSM Parameter Store에 저장
    new ssm.StringParameter(this, 'KnowledgeBaseIdParam', {
      parameterName: '/RAGChatBot/KNOWLEDGE_BASE_ID',
      stringValue: knowledgeBaseId.valueAsString,
    });
    
    // 3) IAM Role to access EC2
    const instanceRole = new iam.Role(this, 'InstanceRole', {
      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('AdministratorAccess'),
      ],
    });

    // // Network setting for EC2
    // const defaultVpc = ec2.Vpc.fromLookup(this, 'VPC', {
    //   isDefault: true,
    // });

    // 4) 기존 VPC ID와 Subnet IDs를 ImportValue로 가져오기
    //    예: PoCVPCIDExport, PoCPublicSubnetId1, PoCPublicSubnetId2 라고 가정
    const existingVpcId = cdk.Fn.importValue('PoCVPCIDExport'); // <-- 기존 VPC ID를 import
    const publicSubnetId1 = cdk.Fn.importValue('PoCPublicSubnetId1');
    const publicSubnetId2 = cdk.Fn.importValue('PoCPublicSubnetId2');

    // 5) 해당 VPC의 서브넷들(퍼블릭/프라이빗)도 같이 알아야 Instance를 만들 수 있음
    //    보통 VPC Output에 SubnetId 리스트도 Export하거나, VPC Lookup / fromLookup()을 쓰기도 함.
    //    여기서는 단순히 VPC ID만 가져와서 Subnet을 ALL matching 시도
    //    필요 시, Subnet IDs를 별도로 importValue('MySubnetId1Export') 로 가져와서 SubnetSelection에 명시 가능
    // --------------------------------------------------------------
    const myExistingVpc = ec2.Vpc.fromVpcAttributes(this, 'MyExistingVpc', {
      vpcId: existingVpcId,
      availabilityZones: [ 'ap-northeast-2a', 'ap-northeast-2b' ], // 실제 AZ
      // 아래는 예시. subnet Id를 knownSubnets로 등록할 수도 있음:
      publicSubnetIds: [publicSubnetId1, publicSubnetId2],
      // privateSubnetIds: [ cdk.Fn.importValue('MyPrivateSubnetId1'), cdk.Fn.importValue('MyPrivateSubnetId2') ],
    });

    // 6) Security Group
    const chatbotAppSecurityGroup = new ec2.SecurityGroup(this, 'chatbotAppSecurityGroup', {
      vpc: myExistingVpc,
    });
    chatbotAppSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(80),
      'httpIpv4',
    );
    chatbotAppSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(22),
      'sshIpv4',
    );

    // 7) set AMI: Amazon Linux 2023
    const machineImage = ec2.MachineImage.fromSsmParameter(
      '/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64'
    );
        
    // 8) set User Data
    const userData = ec2.UserData.forLinux();
    const userDataScript = fs.readFileSync(path.join(__dirname, 'userdata.sh'), 'utf8');
    userData.addCommands(userDataScript);

    // 9) EC2 instance
    const chatbotAppInstance = new ec2.Instance(this, 'chatbotAppInstance', {
      instanceType: new ec2.InstanceType('t3.small'),
      machineImage: machineImage,
      vpc: myExistingVpc,
      securityGroup: chatbotAppSecurityGroup,
      role: instanceRole,
      userData: userData,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PUBLIC,
      },
    });

    // 10) 출력
    new cdk.CfnOutput(this, 'chatbotAppUrl', {
      value: `http://${chatbotAppInstance.instancePublicIp}/`,
      description: '[PLEASE CONNECT IN 5 MINUTES] The URL of chatbot demo generated by AWS CDK',
      exportName: 'chatbotAppUrl',
    });
  }
}